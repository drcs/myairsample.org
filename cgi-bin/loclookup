#!/usr/bin/python
#-*-python-*-
#
# Look-up and Conversion of Levels of Concern
# (c) 2012 Gwen Ottinger
# (c) 2012 Greg Benison
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

import cgi;
import cgitb
cgitb.enable()

import re
import csv

from genshi.template import TemplateLoader

# --------------------------------------------------------------------
# Read the form data
# --------------------------------------------------------------------
form = cgi.FieldStorage()

# look for all 'chem*' parameters that have a corresponding 'report*' parameter
chem_pattern = re.compile('^chem(\d+)$')
def chem_lookup(chem_par):
    n = chem_pattern.findall(chem_par)[0]
    report_par = 'report' + n
    return { 'name'  : form[chem_par].value.lower(),
             'level' : form[report_par].value if report_par in form else 'NA' }

chemicals = map (chem_lookup, filter (chem_pattern.match, form.keys()))

# ---------------------------------------------------------------------
# Read the standards tables
# ---------------------------------------------------------------------

def dict_from_csv_fname(fname, col_idx=0, dialect=False, key_xform = lambda(k): k.strip().lower(), value_xform = lambda(v): v):
    """Read a CSV file, attempting to determine its dialect if none specified.
       Create a dictionary keyed on 'col_idx', optionally transforming the key
       and value (which defaults to the entire row)."""
    result = {}
    with open(fname, 'rb') as csvfile:
        if not dialect:
            dialect = csv.Sniffer().sniff(csvfile.read(1024))
            csvfile.seek(0)
        for row in csv.reader(csvfile,dialect):
            if len(row) > col_idx:
                result[key_xform(row[col_idx])] = value_xform(row)
    return result

def select_field(n, default=False): return lambda(row): row[n] if len(row) > n else default

def zip_to_dict(keys, values):
    result = {}
    for (key,value) in zip (keys, values): result[key] = value
    return result

def row_mapper(keys):
    """Convert an array to a dictionary with the given keys"""
    return lambda(row): zip_to_dict(keys, row)

cas_no        = dict_from_csv_fname('datatables/synonyms.txt', 0, value_xform=select_field(1))
mw_by_cas     = dict_from_csv_fname('datatables/synonyms.txt', 1, value_xform=select_field(2))
ncstds_by_cas = dict_from_csv_fname('datatables/ncstds.txt',   1, value_xform=row_mapper(['name','cas','ncann','nc24','nc1a','nc1b']))

# append some metadata to chemicals
for chemical in chemicals:
    if chemical["name"] in cas_no:
        cas = cas_no[chemical["name"]]
        chemical["cas"] = cas
        if cas in ncstds_by_cas:
            chemical["ncstds"] = ncstds_by_cas[cas]

# ---------------------------------------------------------------------
# Units conversion
# ---------------------------------------------------------------------
# FIXME: throw exception when mw lacking
def convert_units(level, from_units, to_units, mw=False):
    factor = { 'ppb'         : 1.0   ,
               'ugm3'        : 1.198 ,
               'ppbv'        : 24.04 / mw }
    return level / factor[from_units] * factor[to_units]

# -------------------------------------------------------------------------------
# Load the report template and generate the output
# -------------------------------------------------------------------------------
loader = TemplateLoader('.')
tmpl = loader.load('report-template.html')

# HTTP headers
print "Content-type: text/html"
print

print chemicals
print tmpl.generate(chemicals = chemicals).render('html', doctype='html')
