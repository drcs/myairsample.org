#!/usr/bin/python
#-*-python-*-
#
# Look-up and Conversion of Levels of Concern
# (c) 2012 Gwen Ottinger
# (c) 2012 Greg Benison
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

import cgi;
import cgitb
cgitb.enable()

import re
import csv

from genshi.template import TemplateLoader

# --------------------------------------------------------------------
# Read the form data
# --------------------------------------------------------------------
form = cgi.FieldStorage()

# look for all 'chem*' parameters that have a corresponding 'report*' parameter
chem_pattern = re.compile('^chem(\d+)$')
def chem_lookup(chem_par):
    n = chem_pattern.findall(chem_par)[0]
    report_par = 'report' + n
    return { 'name'  : form[chem_par].value.lower(),
             'level' : form[report_par].value if report_par in form else 'NA' }

chemicals = map (chem_lookup, filter (chem_pattern.match, form.keys()))
units = {'in'  : form.getvalue('inunits'),
         'out' : form.getvalue('outunits')}

# ---------------------------------------------------------------------
# Read the standards tables
# ---------------------------------------------------------------------

def standard_cleanup(s):
    try: return s.lower().strip()
    except AttributeError: return s

def csv_file_reader(fname, fieldnames=None, dialect=None):
    csvfile = open(fname,'rb')
    if dialect == None:
        dialect = csv.Sniffer().sniff(csvfile.read(1024))
        csvfile.seek(0)
    return csv.DictReader(csvfile, fieldnames, dialect=dialect)

def key_csv_by(reader, key, cleanup=standard_cleanup):
    """Given a csv.DictReader, return a dictionary of its rows keyed by one of the columns"""
    result = {}
    for row in reader:
        if key in row:
            result[cleanup(row[key])] = row
    return result

synonym_by_name    = key_csv_by(csv_file_reader('datatables/synonyms.txt', fieldnames=['name','cas','mw']),                         'name')
synonym_by_cas     = key_csv_by(csv_file_reader('datatables/synonyms.txt', fieldnames=['name','cas','mw']),                         'cas')

def read_criteria(fname, fieldnames, column, units):
    criteria_by_cas = key_csv_by(csv_file_reader('datatables/' + fname, fieldnames=fieldnames), 'cas')
    return [{'source'   : fname,
             'criteria' : criteria_by_cas,
             'column'   : column,
             'units'    : units}]

def list_flatten(xs):
    result = []
    for x in xs: result += x
    return result

# FIXME multiple criteria are available per file
reporting_criteria = list_flatten([
        read_criteria('ncstds.txt',
                      ['name','cas','ncann','nc24','nc1a','nc1b'],
                      'nc24',
                      'mg/m3'),
        read_criteria('tesl.txt',
                      ['name','cas','tshort','tinter','tlong'],
                      'tshort',
                      'ug/m3'),
        read_criteria('r6sls.txt',
                      ['name','cas','r6sl'],
                      'r6sl',
                      'ug/m3'),
        read_criteria('ATSDRMRLs.txt',
                      ['name','cas','atsdrac','atsdrint','atsdrchr'],
                      'atsdrac',
                      'ppm'),
        read_criteria('lastds.txt',
                      ['name','cas','la8','la24'],
                      'la8',
                      'ug/m3')])

# FIXME restrict according to selected criteria
criteria_full = reporting_criteria

def describe_comparison(level,reference):
    """Describe the comparison between a level and a reference as an integer ratio,
       and one of Gwen's descriptive words"""
    compare = level / reference
    decimal = compare - int(compare)
    factor  = int(compare)
    description = 'unknown'
    if (compare <= 1.0):
        return { 'factor': int(compare), 'description': 'ok' }
    else:
        if (compare < 1.8):   return { 'factor': int(compare), 'description': 'exceeds' }
        elif (decimal < 0.2): return { 'factor': int(compare), 'description': 'about'   }
        elif (decimal < 0.8): return { 'factor': int(compare), 'description': 'over'    }
        else: return { 'factor' : int(compare) + 1, 'description': 'nearly' }

# ---------------------------------------------------------------------
# Units conversion
# ---------------------------------------------------------------------
# FIXME: throw exception when mw lacking
def convert_units(level, from_units, to_units, mw=False):
    factor = { 'ppm'         : 1.0 ,
               'ppb'         : 1000.0 ,
               'ug/m3'       : 1198.0 ,
               'mg/m3'       : 1.198 }
    if ((from_units == 'ppbv') or (to_units == 'ppbv')):
        factor['ppbv'] = 24040.0 / mw
    return level / factor[from_units] * factor[to_units]

# Add parameter 'out_level' to chemicals; reported level in output units
for chemical in chemicals:
    level = float(chemical['level'])
    chemical['out_level'] = convert_units(level, units['in'], units['out'])

# -------------------------------------------------------------------------------
# Load the report template and generate the output
# -------------------------------------------------------------------------------
loader = TemplateLoader('.')
tmpl = loader.load('report-template.html')

# HTTP headers
print "Content-type: text/html"
print

# FIXME debugging output
print chemicals

def report_criterion(chemical, criterion):
    cas = synonym_by_name[standard_cleanup(chemical['name'])]['cas']
    standard_level = (criterion['criteria'][cas][criterion['column']]).strip()
    if standard_level != '':
        return convert_units(float(standard_level), criterion['units'], units['out'])
    else:
        return '--'

def over_criterion(chemical, criterion):
    # FIXME stub -- should return 'concern' only if level should be flagged
    return 'nac'


document = tmpl.generate(chemicals        = chemicals,
                         recipient        = [form.getvalue('tablename',False),
                                             form.getvalue('tablename2',False)],
                         units            = units,
                         criteria_full    = criteria_full,
                         report_criterion = report_criterion,
                         over_criterion   = over_criterion)
                                 
print document.render('html', doctype='html')
