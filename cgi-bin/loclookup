#!/usr/bin/python
#-*-python-*-
#
# Look-up and Conversion of Levels of Concern
# (c) 2012 Gwen Ottinger
# (c) 2012 Greg Benison
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#

import cgi;
import cgitb
cgitb.enable()

import re
import csv

from genshi.template import TemplateLoader

# --------------------------------------------------------------------
# Read the form data
# --------------------------------------------------------------------
form = cgi.FieldStorage()

# look for all 'chem*' parameters that have a corresponding 'report*' parameter
chem_pattern = re.compile('^chem(\d+)$')
def chem_lookup(chem_par):
    n = chem_pattern.findall(chem_par)[0]
    report_par = 'report' + n
    return { 'name'  : form[chem_par].value.lower(),
             'level' : form[report_par].value if report_par in form else 'NA' }

chemicals = map (chem_lookup, filter (chem_pattern.match, form.keys()))

# ---------------------------------------------------------------------
# Read the standards tables
# ---------------------------------------------------------------------

def standard_cleanup(s):
    try: return s.lower().strip()
    except AttributeError: return s

def csv_file_reader(fname, fieldnames=None, dialect=None):
    csvfile = open(fname,'rb')
    if dialect == None:
        dialect = csv.Sniffer().sniff(csvfile.read(1024))
        csvfile.seek(0)
    return csv.DictReader(csvfile, fieldnames, dialect=dialect)

def key_csv_by(reader, key, cleanup=standard_cleanup):
    """Given a csv.DictReader, return a dictionary of its rows keyed by one of the columns"""
    result = {}
    for row in reader:
        if key in row:
            result[cleanup(row[key])] = row
    return result

synonym_by_name    = key_csv_by(csv_file_reader('datatables/synonyms.txt', fieldnames=['name','cas','mw']),'name')
synonym_by_cas     = key_csv_by(csv_file_reader('datatables/synonyms.txt', fieldnames=['name','cas','mw']),'cas')
ncstds_by_cas      = key_csv_by(csv_file_reader('datatables/ncstds.txt',   fieldnames=['name','cas','ncann','nc24','nc1a','nc1b']),'cas')

# append some metadata to chemicals
for chemical in chemicals:
    name = standard_cleanup(chemical["name"])
    if name in synonym_by_name:
        cas = synonym_by_name[name]['cas']
        chemical["cas"] = cas
        if cas in ncstds_by_cas:
            chemical["ncstds"] = ncstds_by_cas[cas]

# ---------------------------------------------------------------------
# Units conversion
# ---------------------------------------------------------------------
# FIXME: throw exception when mw lacking
def convert_units(level, from_units, to_units, mw=False):
    factor = { 'ppb'         : 1.0   ,
               'ugm3'        : 1.198 ,
               'ppbv'        : 24.04 / mw }
    return level / factor[from_units] * factor[to_units]

# -------------------------------------------------------------------------------
# Load the report template and generate the output
# -------------------------------------------------------------------------------
loader = TemplateLoader('.')
tmpl = loader.load('report-template.html')

# HTTP headers
print "Content-type: text/html"
print

print chemicals
print tmpl.generate(chemicals = chemicals).render('html', doctype='html')
